<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Perfume Racks with Notion Data</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }

    #dragIndicator {
      position: absolute;
      top: 8px;
      left: 8px;
      color: white;
      background-color: rgba(0,0,0,0.5);
      padding: 4px 8px;
      display: none;
      border-radius: 4px;
      font-family: sans-serif;
    }

    /* Ensure the filterBox is hidden by default */
    #filterBox {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 30%;
      background-color: rgba(255, 255, 255, 0.8);
      border: 1px solid #ccc;
      box-sizing: border-box;
      padding: 8px;
      z-index: 9999;
      display: none;
    }

    /* Help window style */
    #helpWindow {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 34vw;
      height: 30vh;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 16px;
      border-radius: 8px 0 0 0;
      display: none;
      overflow: auto;
      z-index: 9999;
      font-family: sans-serif;
      font-size: 14px;
    }

    #helpHint {
      position: absolute;
      bottom: 8px;
      left: 8px;
      color: white;
      background-color: rgba(50, 100, 150, 0.8);
      padding: 6px 10px;
      border-radius: 4px;
      font-family: sans-serif;
      font-weight: bold;
      z-index: 10000;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <!-- Three.js, OrbitControls, and additional modules for PBR -->
  <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/RGBELoader.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/HDRCubeTextureLoader.js"></script>
  
  <!-- Remove post-processing that was causing issues -->
  <script>
    // -------------------------------------------
    // Global Scene Variables
    // -------------------------------------------
    let scene, camera, renderer, controls, composer;
    let lastFilterMatches = [];
    const raycaster = new THREE.Raycaster();
    const mouse     = new THREE.Vector2();
    let envMap;
    let pmremGenerator, pmremCubeUVPacker;

    // Marking system for flying bottles
    let sourceBottle = null;
    let targetBottle = null;

    function markAsSource(bottle) {
      if (sourceBottle) revertMark(sourceBottle);
      sourceBottle = bottle;
      if (bottle) {
        // set color to green
        const highlightables = bottle.userData.highlightables || [];
        highlightables.forEach(h => {
          h.mesh.material.color.set(0x00ff00);
        });
      }
    }

    function markAsTarget(bottle) {
      if (targetBottle) revertMark(targetBottle);
      targetBottle = bottle;
      if (bottle) {
        // set color to blue
        const highlightables = bottle.userData.highlightables || [];
        highlightables.forEach(h => {
          h.mesh.material.color.set(0x0000ff);
        });
      }
    }

    function revertMark(bottle) {
      if (!bottle) return;
      const highlightables = bottle.userData.highlightables || [];
      highlightables.forEach(h => {
        h.mesh.material.color.copy(h.originalColor);
      });
      if (bottle === sourceBottle) sourceBottle = null;
      if (bottle === targetBottle) targetBottle = null;
    }

    function swapBottlePositions(bottleA, bottleB) {
      // occupant swap logic
      const Aplane = bottleA.userData.plane;
      const Arow   = bottleA.userData.row;
      const Acol   = bottleA.userData.column;
      const Bplane = bottleB.userData.plane;
      const Brow   = bottleB.userData.row;
      const Bcol   = bottleB.userData.column;

      const Akey = `${Aplane}-${Arow}-${Acol}`;
      const Bkey = `${Bplane}-${Brow}-${Bcol}`;

      const Apos = planeLayouts[Aplane].find(s => s.row === Arow && s.column === Acol);
      const Bpos = planeLayouts[Bplane].find(s => s.row === Brow && s.column === Bcol);

      if (Apos && Bpos) {
        // Swap occupant references
        slotOccupants[Akey] = bottleB;
        slotOccupants[Bkey] = bottleA;

        // Move the bottles
        bottleA.position.set(Bpos.x, Bpos.y, Bpos.z);
        bottleB.position.set(Apos.x, Apos.y, Apos.z);

        // Update userData for new plane/row/col
        bottleA.userData.plane = Bplane;
        bottleA.userData.row   = Brow;
        bottleA.userData.column= Bcol;
        bottleA.userData.initialY = Bpos.y;

        bottleB.userData.plane = Aplane;
        bottleB.userData.row   = Arow;
        bottleB.userData.column= Acol;
        bottleB.userData.initialY = Apos.y;

        // Update Notion
        updateBottleSlotOnServer(bottleA.userData.notionData.id, Bplane, Brow, Bcol);
        updateBottleSlotOnServer(bottleB.userData.notionData.id, Aplane, Arow, Acol);
      }
    }

    // We'll store all clickable bottle meshes here:
    const clickableBottles = [];

    // For the "fly" effect:
    const MOVE_SPEED  = 2;
    const FLY_OFFSET  = 32;
    let activeBottle  = null;

    // Dimensions for racks/slots
    const SLOT_WIDTH_DEPTH = 15;
    const BOTTLE_HEIGHT    = 64;

    // The config object from /api/config
    let config = {
      rackR1: "",
      rackR2: "",
      rackR3: "",
      rackR4: "",
      planeP1: "",
      planeP2: "",
      planeP3: "",
      planeP4: "",
      planeVerticalOffset: "2",
      offsetRack: "1",
      capColorDefault: "Gold"
    };

    // We'll store the parsed rack definitions here:
    const racks = {};

    // planeLayouts[planeNumber] = array of { plane, row, column, x, y, z }
    const planeLayouts = {};

    // Occupancy map: "plane-row-col" => bottleGroup
    const slotOccupants = {};

    // Drag mode toggles
    let dragMode = false;
    let draggingBottle = null;

    // We'll track the plane used during drag to set (x,z)
    let dragPlane = null;
    let dragPlaneIntersect = new THREE.Vector3();

    // Toolbox & Filter states
    
    window.addEventListener('load', async () => {
      await fetchConfig();
      parseRackConfigs();

      initScene();
      buildAllPlanes();

      // Now fetch the Notion data
      const notionBottles = await fetchAllNotionBottles();

      // Place each bottle
      notionBottles.forEach(bData => {
        createBottleFromNotion(bData);
      });

      animate();
    });

    // -------------------------------------------
    // 1) Fetch config from server
    // -------------------------------------------
    async function fetchConfig() {
      try {
        const response = await fetch('/api/config');
        if (!response.ok) {
          throw new Error('Failed to load config');
        }
        config = await response.json();
      } catch (err) {
        console.error('Error fetching config:', err);
      }
    }

    // -------------------------------------------
    // 2) Parse environment-based rack definitions
    // -------------------------------------------
    function parseRackConfigs() {
      parseSingleRack("R1", config.rackR1);
      parseSingleRack("R2", config.rackR2);
      parseSingleRack("R3", config.rackR3);
      parseSingleRack("R4", config.rackR4);
    }

    function parseSingleRack(rackId, definition) {
      const match = /^\((\d+),(\d+)\)$/.exec((definition || "").trim());
      if (!match) {
        racks[rackId] = { rows: 0, columns: 0 };
      } else {
        racks[rackId] = {
          rows: parseInt(match[1], 10),
          columns: parseInt(match[2], 10)
        };
      }
    }

    function parsePlaneDefinition(str) {
      return (str || "").split('x').map(s => s.trim());
    }

    // -------------------------------------------
    // 3) Initialize Scene, Camera, Controls
    // -------------------------------------------
    function initScene() {
      scene = new THREE.Scene();
      
      // Create a gradient background texture instead of a solid color
      const bgTexture = createGradientBackground();
      scene.background = bgTexture;
      
      // Helper function to create a soft, elegant background gradient
      function createGradientBackground() {
        const canvas = document.createElement('canvas');
        canvas.width = 2;
        canvas.height = 512;
        const context = canvas.getContext('2d');
        
        // Create a vertical gradient - soft lavender to light cream
        const gradient = context.createLinearGradient(0, 0, 0, 512);
        gradient.addColorStop(0, '#f3e9f9'); // Light lavender at top
        gradient.addColorStop(0.5, '#f0f0f6'); // Middle - soft gray-lavender
        gradient.addColorStop(1, '#fff9f2'); // Warm cream at bottom
        
        context.fillStyle = gradient;
        context.fillRect(0, 0, 2, 512);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.needsUpdate = true;
        
        return texture;
      }

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(3, 180, 220);

      // Initialize renderer with physically correct lighting
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.physicallyCorrectLights = true;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 50, 0);
      controls.update();

      // Create environment map for reflections
      setupEnvironmentMap();

      // Create PBR-compatible lighting
      setupPBRLighting();
      
      // Setup post-processing
      setupPostProcessing();

      // Event Listeners
      renderer.domElement.addEventListener('mousedown', onDocumentMouseDown);
      renderer.domElement.addEventListener('mousemove', onDocumentMouseMove);
      renderer.domElement.addEventListener('mouseup', onDocumentMouseUp);

      window.addEventListener('resize', onWindowResize);
      
      // Setup functions for PBR rendering
      function setupEnvironmentMap() {
        // Create a procedural environment map since we don't have an HDR file
        pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileCubemapShader();
        
        // Create a simple environment with gradient
        const environmentTexture = generateEnvironmentTexture();
        const environmentCubeRenderTarget = pmremGenerator.fromEquirectangular(environmentTexture);
        envMap = environmentCubeRenderTarget.texture;
        
        scene.environment = envMap; // Set the environment map for all PBR materials
        environmentTexture.dispose();
      }
      
      function generateEnvironmentTexture() {
        // Create a procedural environment texture (gradient sky)
        const canvas = document.createElement('canvas');
        canvas.width = 1024;
        canvas.height = 512;
        const context = canvas.getContext('2d');
        
        // Create a gradient for a simple sky
        const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#4287f5'); // Blue sky at top
        gradient.addColorStop(0.5, '#a7c5f9'); // Lighter blue in middle
        gradient.addColorStop(1, '#ffffff'); // White at horizon
        
        context.fillStyle = gradient;
        context.fillRect(0, 0, canvas.width, canvas.height);
        
        // Add some simple clouds
        context.fillStyle = 'rgba(255, 255, 255, 0.4)';
        for (let i = 0; i < 15; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height * 0.5;
          const radius = 20 + Math.random() * 60;
          context.beginPath();
          context.arc(x, y, radius, 0, Math.PI * 2);
          context.fill();
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.mapping = THREE.EquirectangularReflectionMapping;
        return texture;
      }
      
      function setupPBRLighting() {
        // Clear any existing lights
        scene.children.forEach(child => {
          if (child.isLight) scene.remove(child);
        });
        
        // Ambient light for general illumination
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
        scene.add(ambientLight);
        
        // Main directional light (like sun)
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.0);
        mainLight.position.set(50, 100, 50);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 1024;
        mainLight.shadow.mapSize.height = 1024;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 500;
        mainLight.shadow.camera.left = -100;
        mainLight.shadow.camera.right = 100;
        mainLight.shadow.camera.top = 100;
        mainLight.shadow.camera.bottom = -100;
        scene.add(mainLight);
        
        // Add some fill lights for better showcase of glass and metals
        const fillLight1 = new THREE.PointLight(0xffffee, 0.5);
        fillLight1.position.set(-50, 100, -50);
        scene.add(fillLight1);
        
        const fillLight2 = new THREE.PointLight(0xeeeeff, 0.5);
        fillLight2.position.set(100, 50, -50);
        scene.add(fillLight2);
      }
      
      function setupPostProcessing() {
        // We're removing the post-processing due to compatibility issues
        // with the version of Three.js being used
        composer = null;
        console.log("Post-processing disabled");
      }

      // Create a small overlay to indicate drag mode
      const dragIndicator = document.createElement('div');
      dragIndicator.id = 'dragIndicator';

      // Title
      const dragIndicatorTitle = document.createElement('div');
      dragIndicatorTitle.id = 'dragIndicatorTitle';
      dragIndicatorTitle.innerText = 'Drag Mode ON';
      dragIndicator.appendChild(dragIndicatorTitle);

      // Bottle name label
      const dragBottleLabel = document.createElement('div');
      dragBottleLabel.id = 'dragBottleLabel';
      dragBottleLabel.style.display = 'none';
      dragIndicator.appendChild(dragBottleLabel);

      // Slot occupant/row-col label
      const dragSlotLabel = document.createElement('div');
      dragSlotLabel.id = 'dragSlotLabel';
      dragSlotLabel.style.display = 'none';
      dragIndicator.appendChild(dragSlotLabel);

      // Cross-plane label
      const dragPlaneMoveLabel = document.createElement('div');
      dragPlaneMoveLabel.id = 'dragPlaneMoveLabel';
      dragPlaneMoveLabel.style.display = 'none';
      dragIndicator.appendChild(dragPlaneMoveLabel);

      document.body.appendChild(dragIndicator);

      // Listen for filter input
      const filterInput = document.getElementById('filterInput');
      if (filterInput) {
        filterInput.addEventListener('input', (ev) => {
          applyFilter(ev.target.value);
        });
      }
    }

    // -------------------------------------------
    // 4) Build planes & racks (just the shelves)
    // -------------------------------------------
    function buildAllPlanes() {
      const planeKeys = ["planeP1","planeP2","planeP3","planeP4"];
      let currentPlaneY = 0;
    
      // First, ensure all plane indices (1..4) have an empty array by default
      for (let i = 1; i <= 4; i++) {
        planeLayouts[i] = [];
      }
    
      planeKeys.forEach((planeKey, index) => {
        const definition = config[planeKey];
        // If no definition, we keep the default empty array and skip building shelves.
        if (!definition) return;
    
        const planeNumber = index + 1;
        const rackIds = parsePlaneDefinition(definition);
        if (!rackIds || !rackIds.length) return;
    
        const planeGroup = new THREE.Group();
        planeGroup.position.set(0, currentPlaneY, index * 12 * SLOT_WIDTH_DEPTH);
        scene.add(planeGroup);

        // We already initialized planeLayouts[planeNumber], so we can safely push slots below

        let rowIndexBase = 0;
        let rowStackOffset = 0;
        const offsetRack = parseFloat(config.offsetRack) || 1;

        rackIds.forEach(rackId => {
          const rDef = racks[rackId] || { rows:0, columns:0 };
          if (rDef.rows <= 0 || rDef.columns <= 0) {
            console.warn("No valid definition for rackId =", rackId);
            return;
          }

          const rows    = rDef.rows;
          const columns = rDef.columns;
          const { group: rackGroup, rowHeights } = createSteppedRack(rows, columns);
          const rackDepth = rows * SLOT_WIDTH_DEPTH;

          rackGroup.position.z = -rowStackOffset;
          planeGroup.add(rackGroup);

          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < columns; c++) {
              const totalWidth = columns * SLOT_WIDTH_DEPTH;
              const slotCenterX = -(totalWidth / 2) + c*SLOT_WIDTH_DEPTH + SLOT_WIDTH_DEPTH/2;
              const slotCenterZ = (rackDepth / 2) - r*SLOT_WIDTH_DEPTH - (SLOT_WIDTH_DEPTH / 2);
              const worldX = slotCenterX;
              const worldY = currentPlaneY + rowHeights[r];
              const worldZ = planeGroup.position.z + rackGroup.position.z + slotCenterZ;

              planeLayouts[planeNumber].push({
                plane: planeNumber,
                row: rowIndexBase + r + 1,
                column: c + 1,
                x: worldX,
                y: worldY,
                z: worldZ
              });
            }
          }

          rowIndexBase += rows;
          rowStackOffset += rackDepth;
          rowStackOffset += offsetRack * rackDepth;
        });

        const planeVerticalOffset = parseFloat(config.planeVerticalOffset) || 2;
        currentPlaneY -= planeVerticalOffset * BOTTLE_HEIGHT;
      });
    }

    function createSteppedRack(numRows, numColumns) {
      const group = new THREE.Group();
      const totalWidth = numColumns * SLOT_WIDTH_DEPTH;
      const totalDepth = numRows * SLOT_WIDTH_DEPTH;
      const rowHeight  = BOTTLE_HEIGHT / 2;
      const wallThickness = 0.1;
      const stepY     = rowHeight * 0.3;
      const baseY     = wallThickness / 2;

      const mat = new THREE.MeshPhysicalMaterial({
        color: 0xe0e0e0,      // Slight off-white for plastic
        roughness: 0.7,       // Higher roughness for plastic
        metalness: 0.0,       // Plastic is not metallic
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide,
        clearcoat: 0.3,       // Light clearcoat for shiny plastic finish
        clearcoatRoughness: 0.4,
        envMap: envMap,
        envMapIntensity: 0.5  // Reduced reflections for plastic
      });

      const rowDepth = totalDepth / numRows;
      function rowCenterZ(i) {
        return totalDepth / 2 - rowDepth / 2 - rowDepth*i;
      }

      // We'll store the "top" y-position for each row so we can place bottles accordingly
      const rowHeights = [];

      for (let i = 0; i < numRows; i++) {
        const rowBaseY = baseY + stepY*i;
        // This is the top of the floor for row i
        rowHeights.push(rowBaseY + wallThickness);

        const centerZ  = rowCenterZ(i);

        // floor
        const floorGeom = new THREE.BoxGeometry(totalWidth, wallThickness, rowDepth);
        const floorMesh = new THREE.Mesh(floorGeom, mat);
        floorMesh.position.set(0, rowBaseY, centerZ);
        group.add(floorMesh);

        // vertical dividers
        for (let j = 1; j < numColumns; j++) {
          const dividerGeom = new THREE.BoxGeometry(wallThickness, rowHeight, rowDepth - 2*wallThickness);
          const divider     = new THREE.Mesh(dividerGeom, mat);
          const xPos        = -totalWidth/2 + (totalWidth/numColumns)*j;
          divider.position.set(
            xPos,
            rowBaseY + wallThickness + rowHeight/2,
            centerZ
          );
          group.add(divider);
        }

        // side walls
        const sideGeom   = new THREE.BoxGeometry(wallThickness, rowHeight, rowDepth);
        const leftWall   = new THREE.Mesh(sideGeom, mat);
        leftWall.position.set(
          -totalWidth/2 + wallThickness/2,
          rowBaseY + wallThickness + rowHeight/2,
          centerZ
        );
        group.add(leftWall);

        const rightWall  = new THREE.Mesh(sideGeom, mat);
        rightWall.position.set(
          totalWidth/2 - wallThickness/2,
          rowBaseY + wallThickness + rowHeight/2,
          centerZ
        );
        group.add(rightWall);
      }

      // front wall
      const frontWallGeom = createBeveledWall(totalWidth, rowHeight, wallThickness, 0.2, 0.05);
      const frontWall     = new THREE.Mesh(frontWallGeom, mat);
      frontWall.rotation.y = Math.PI;
      frontWall.position.set(0, baseY, totalDepth/2);
      group.add(frontWall);

      // back wall
      const extraHeight  = (numRows - 1) * stepY;
      const backWallGeom = createBeveledWall(totalWidth, rowHeight + extraHeight, wallThickness, 0.2, 0.05);
      const backWall     = new THREE.Mesh(backWallGeom, mat);
      backWall.position.set(0, baseY, -totalDepth/2);
      group.add(backWall);

      // internal walls between steps
      for (let i = 0; i < numRows - 1; i++) {
        const lowerY = baseY + stepY*(i+1);
        const upperY = baseY + stepY*i + rowHeight;
        const overlapHeight = upperY - lowerY;
        const boundaryZ = rowCenterZ(i) - rowDepth/2 + wallThickness/2;

        const sharedGeom = new THREE.BoxGeometry(totalWidth, overlapHeight, wallThickness);
        const sharedWall = new THREE.Mesh(sharedGeom, mat);
        sharedWall.position.set(0, lowerY + overlapHeight/2, boundaryZ);
        group.add(sharedWall);
      }

      // Return both the rack group and the array of rowHeights
      return { group, rowHeights };
    }

    function createBeveledWall(width, height, depth, bevelSize, bevelThickness) {
      const shape = new THREE.Shape();
      shape.moveTo(-width/2, 0);
      shape.lineTo(width/2, 0);
      shape.lineTo(width/2, height);
      shape.lineTo(-width/2, height);
      shape.lineTo(-width/2, 0);

      const extrudeSettings = {
        steps: 1,
        depth: depth,
        bevelEnabled: true,
        bevelThickness: bevelThickness,
        bevelSize: bevelSize,
        bevelSegments: 1
      };
      return new THREE.ExtrudeGeometry(shape, extrudeSettings);
    }

    // -------------------------------------------
    // 5) Fetch the Notion Bottles
    // -------------------------------------------
    async function fetchAllNotionBottles() {
      try {
        const response = await fetch('/api/bottles');
        if (!response.ok) {
          throw new Error(`Failed to fetch /api/bottles. Status = ${response.status}`);
        }
        const data = await response.json();
        return data;
      } catch (err) {
        console.error('fetchAllNotionBottles error:', err);
        return [];
      }
    }

    // -------------------------------------------
    // 6) Create Bottles in the Correct Position
    // -------------------------------------------
    function createBottleFromNotion(bData) {
      const { plane, row, column, name, capColor, id, house, accords, type } = bData;
      if (!planeLayouts[plane]) {
        console.warn(`No plane layout found for plane=${plane}`);
        return;
      }

      const slot = planeLayouts[plane].find(s => s.row === row && s.column === column);
      if (!slot) {
        console.warn(`No slot found for plane=${plane}, row=${row}, column=${column}`);
        return;
      }

      const bottleGroup = new THREE.Group();
      const bottleWidth  = 10;
      const bottleDepth  = 10;
      const bottleHeight = BOTTLE_HEIGHT;
      const capHeight    = 15;
      const capRadius    = 5;

      // Enhanced bottle body with realistic glass using PBR
      const bottleGeo = new THREE.BoxGeometry(bottleWidth, bottleHeight, bottleDepth);
      
      // Get a subtle glass color based on perfume type or house
      const glassColorHex = getBottleGlassColor(bData);
      
      // Create advanced glass material with PBR properties - refined for realistic glass
      const bottleMat = new THREE.MeshPhysicalMaterial({
        color: glassColorHex,
        metalness: 0.0,
        roughness: 0.01,      // Smoother for glass
        transmission: 0.92,   // Amount of light that passes through
        thickness: 1.8,       // Glass thickness for refraction
        envMap: envMap,       // Environment map for reflections
        envMapIntensity: 1.5, // Enhanced reflections for glass
        clearcoat: 0.7,       // Enhanced clear coat for glass shine
        clearcoatRoughness: 0.05,
        ior: 1.52,            // Index of refraction for glass (1.52 is more accurate)
        transparent: true,
        opacity: 0.92,
        reflectivity: 0.2     // Glass reflectivity
      });
      
      // Apply material to mesh
      const bottleMesh = new THREE.Mesh(bottleGeo, bottleMat);
      bottleMesh.position.set(0, bottleHeight/2, 0);
      bottleMesh.castShadow = true;
      bottleMesh.receiveShadow = true;

      // Label with improved quality
      const labelWidth  = bottleWidth;
      const labelHeight = bottleHeight / 2;
      const labelGeo = new THREE.PlaneGeometry(labelWidth, labelHeight);
      const labelTexture = createLabelTexture(name || "(No Name)");
      
      // Improved label material
      const labelMat = new THREE.MeshStandardMaterial({
        map: labelTexture,
        side: THREE.DoubleSide,
        transparent: true,
        roughness: 0.7,     // Paper-like roughness
        metalness: 0.0
      });
      
      const labelMesh = new THREE.Mesh(labelGeo, labelMat);
      labelMesh.position.set(0, 0, bottleDepth/2 + 0.01);
      bottleMesh.add(labelMesh);

      // Enhanced cap with metallic PBR properties
      const capGeo = new THREE.CylinderGeometry(capRadius, capRadius, capHeight, 32);
      
      // Create a map for metallic caps
      let capMetalness = 1.0;
      let capRoughness = 0.2;
      
      // Determine cap material properties based on color
      if (capColor === 'Gold') {
        capMetalness = 1.0;
        capRoughness = 0.1;
      } else if (capColor === 'Silver') {
        capMetalness = 0.95;
        capRoughness = 0.1;
      } else if (capColor === 'Black') {
        capMetalness = 0.8;
        capRoughness = 0.3;
      }
      
      // Enhanced cap material with PBR
      const capMat = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        roughness: capRoughness,
        metalness: capMetalness,
        envMap: envMap
      });
      
      if (capColor) {
        try {
          capMat.color.setStyle(capColor);
        } catch {
          capMat.color.set(0xffd700);
        }
      }
      
      const capMesh = new THREE.Mesh(capGeo, capMat);
      capMesh.position.set(0, bottleHeight + capHeight/2, 0);
      capMesh.castShadow = true;
      capMesh.receiveShadow = true;

      bottleGroup.add(bottleMesh);
      bottleGroup.add(capMesh);

      bottleGroup.position.set(slot.x, slot.y, slot.z);

      // Store custom data, including references to meshes for highlight
      bottleGroup.userData = {
        initialY: slot.y,
        flying: false,
        notionData: bData,
        plane: plane,
        row: row,
        column: column,
        house: house,
        accords: accords,
        type: type,
        highlightables: [
          { mesh: bottleMesh, originalColor: bottleMesh.material.color.clone() },
          { mesh: capMesh, originalColor: capMesh.material.color.clone() }
        ]
      };
      clickableBottles.push(bottleGroup);
      scene.add(bottleGroup);

      // Mark this slot occupant
      const key = `${plane}-${row}-${column}`;
      if (slotOccupants[key]) {
        console.warn(`Multiple occupant in slot ${key}: occupant = ${slotOccupants[key].userData.notionData.name}, new occupant = ${bData.name}`);
      }
      slotOccupants[key] = bottleGroup;
    }

    // Helper function to determine bottle glass color based on perfume type/characteristics
    function getBottleGlassColor(bottleData) {
      // Default subtle light blue-tinted glass
      let glassColor = 0xF0F8FF;
      
      // If we have accords data, use it to influence glass color
      if (bottleData.accords && bottleData.accords.length > 0) {
        // Map common perfume accords to subtle glass tints
        const accordColorMap = {
          'floral': 0xFFF0F5,        // Very light pink
          'woody': 0xF5DEB3,         // Light wheat
          'fresh': 0xE0FFFF,         // Light cyan
          'citrus': 0xFFFACD,        // Lemon chiffon
          'spicy': 0xFFE4B5,         // Moccasin
          'sweet': 0xFFE4E1,         // Misty rose
          'amber': 0xFFD700,         // Gold
          'powdery': 0xFFF0F5,       // Lavender blush
          'aromatic': 0xF0FFF0,      // Honeydew
          'fruity': 0xFFF0F5,        // Light pink
          'green': 0xF0FFF0,         // Honeydew
          'marine': 0xE0FFFF,        // Light cyan
          'vanilla': 0xFFF8DC,       // Cornsilk
          'oud': 0xDEB887,           // Burlywood
          'leather': 0xD2B48C,       // Tan
          'musky': 0xE6E6FA          // Lavender
        };
        
        // Check if any accord matches our map
        for (const accord of bottleData.accords) {
          const lowerAccord = accord.toLowerCase();
          // Look for partial matches in our accord map
          for (const [key, color] of Object.entries(accordColorMap)) {
            if (lowerAccord.includes(key)) {
              glassColor = color;
              break;
            }
          }
        }
      }
      
      // House can override accord colors for brand consistency
      if (bottleData.house) {
        const houseLower = bottleData.house.toLowerCase();
        // Map some notable houses to specific glass colors (just examples)
        if (houseLower.includes('dior')) {
          glassColor = 0xF0F8FF; // Light blue-white
        } else if (houseLower.includes('chanel')) {
          glassColor = 0xFFFAFA; // Snow white
        } else if (houseLower.includes('guerlain')) {
          glassColor = 0xFFF5EE; // Seashell
        }
      }
      
      return glassColor;
    }

    function createLabelTexture(text) {
      const canvas  = document.createElement('canvas');
      canvas.width  = 256;
      canvas.height = 819;
      const ctx     = canvas.getContext('2d');

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.font         = "60px Arial";
      ctx.fillStyle    = "#000000";
      ctx.textAlign    = "center";
      ctx.textBaseline = "middle";

      ctx.save();
      ctx.translate(0, canvas.height);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(text, canvas.height / 2, canvas.width / 2);
      ctx.restore();

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    /**
     * Create a 4-line board mesh: line1=house, line2=name, line3, line4.
     */
    function createBoardMesh(house, name, line3, line4) {
      // Larger canvas for better resolution and visibility
      const width  = 384;
      const height = 256;
      const canvas = document.createElement('canvas');
      canvas.width  = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // Helper to measure and clip text if too large
      function clipAndFillText(context, text, maxWidth, x, y, fontStyle = "20px Arial", isBold = false) {
        context.font = fontStyle;
        let clipped = text;
        const ellipsis = '…';
        while (clipped.length > 0 && context.measureText(clipped + ellipsis).width > maxWidth) {
          clipped = clipped.slice(0, -1);
        }
        if (clipped !== text) {
          clipped += ellipsis;
        }
        context.fillText(clipped, x, y);
      }

      // Background with gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, "#f0f8ff");
      gradient.addColorStop(1, "#e6f2ff");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);
      
      // Add subtle border
      ctx.strokeStyle = "#4682b4";
      ctx.lineWidth = 8;
      ctx.strokeRect(4, 4, width - 8, height - 8);
      
      // Inner shadow for depth
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
      ctx.fillRect(12, 12, width - 24, height - 24);
      
      // Background for content area
      ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
      ctx.fillRect(12, 12, width - 24, height - 24);

      // Text styles (baseline, alignment)
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // line1: House (with subtle shadow for better readability)
      ctx.fillStyle = "#444";
      clipAndFillText(ctx, house, 320, width / 2, 48, "bold 24px Arial");

      // line2: Name (larger and bolder)
      ctx.fillStyle = "#000";
      clipAndFillText(ctx, name, 320, width / 2, 100, "bold 32px Arial");

      // Separator line
      ctx.strokeStyle = "#4682b4";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(width/4, 140);
      ctx.lineTo(width*3/4, 140);
      ctx.stroke();

      // line3: custom (e.g. "Press Q or A to move plane up/down")
      ctx.fillStyle = "#333";
      clipAndFillText(ctx, line3, 320, width / 2, 180, "18px Arial");

      // line4: custom dynamic notice (highlight important information)
      ctx.fillStyle = "#1E5AAB";
      clipAndFillText(ctx, line4, 320, width / 2, 220, "bold 18px Arial");

      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;

      // Plane geometry for the board - much larger for better visibility
      const boardGeo = new THREE.PlaneGeometry(64, 48);
      const boardMat = new THREE.MeshBasicMaterial({
        map: tex,
        side: THREE.DoubleSide,
        transparent: true
      });

      const boardMesh = new THREE.Mesh(boardGeo, boardMat);
      boardMesh.renderOrder = 9999; // so it's drawn on top
      return boardMesh;
    }

    // -------------------------------------------
    // 7) Interaction & Drag Logic
    // -------------------------------------------
    function onDocumentMouseDown(event) {
      event.preventDefault();

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      // If we are in drag mode, attempt to pick up a bottle
      if (dragMode) {
        const intersects = raycaster.intersectObjects(clickableBottles, true);
        if (intersects.length > 0) {
          let clickedGroup = intersects[0].object;
          while (clickedGroup.parent && !clickableBottles.includes(clickedGroup)) {
            clickedGroup = clickedGroup.parent;
          }
          draggingBottle = clickedGroup;
          
          // Show which bottle is being dragged
          const dragBottleLabel = document.getElementById('dragBottleLabel');
          const dragSlotLabel = document.getElementById('dragSlotLabel');
          dragBottleLabel.style.display = 'block';
          dragBottleLabel.innerText = `Dragging: ${draggingBottle.userData.notionData.name}`;
          dragSlotLabel.style.display = 'block';
          dragSlotLabel.innerText = '';

          

          const oldKey = `${draggingBottle.userData.plane}-${draggingBottle.userData.row}-${draggingBottle.userData.column}`;
          if (slotOccupants[oldKey] === draggingBottle) {
            delete slotOccupants[oldKey];
          }
          dragPlane = new THREE.Plane(new THREE.Vector3(0,1,0), -draggingBottle.position.y);
        }
        return;
      }

      // Normal "fly" logic
      const intersects = raycaster.intersectObjects(clickableBottles, true);

      if (intersects.length > 0) {
        let clickedGroup = intersects[0].object;
        while (clickedGroup.parent && !clickableBottles.includes(clickedGroup)) {
          clickedGroup = clickedGroup.parent;
        }
        if (activeBottle && activeBottle !== clickedGroup) {
          activeBottle.userData.flying = false;
        }
        if (clickedGroup) {
          if (activeBottle !== clickedGroup) {
            activeBottle = clickedGroup;
            activeBottle.userData.flying = true;
          } else {
            activeBottle.userData.flying = !activeBottle.userData.flying;
          }
        }
      } else {
        if (activeBottle) {
          activeBottle.userData.flying = false;
          activeBottle = null;
        }
      }
    }

    function onDocumentMouseMove(event) {
      if (isFilterBoxVisible()) return;
      if (!dragMode || !draggingBottle) return;

      event.preventDefault();

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);

      if (dragPlane) {
        if (raycaster.ray.intersectPlane(dragPlane, dragPlaneIntersect)) {
          draggingBottle.position.x = dragPlaneIntersect.x;
          draggingBottle.position.z = dragPlaneIntersect.z;

          // Show the occupant or row/col of the nearest slot
          const dragPlaneNum = (draggingBottle.userData.dragPlaneNum !== undefined)
            ? draggingBottle.userData.dragPlaneNum
            : draggingBottle.userData.plane;
          const nearest = findNearestSlotInPlane(dragPlaneNum, draggingBottle.position.x, draggingBottle.position.z);
          const dragSlotLabel = document.getElementById('dragSlotLabel');
          if (nearest) {
            const key = `${nearest.plane}-${nearest.row}-${nearest.column}`;
            const occupant = slotOccupants[key];
            if (occupant && occupant !== draggingBottle) {
              dragSlotLabel.innerText = `Slot occupant: ${occupant.userData.notionData.name}`;
            } else {
              dragSlotLabel.innerText = `Slot: row=${nearest.row}, col=${nearest.column}`;
            }
          } else {
            dragSlotLabel.innerText = '(No nearest slot in this plane)';
          }
        }
      }
    }

    async function onDocumentMouseUp(event) {
      if (isFilterBoxVisible()) return;
      if (!dragMode || !draggingBottle) return;

      event.preventDefault();
      event.preventDefault();

      // Use the dragPlaneNum if set, otherwise fallback to the original plane
      const finalPlane = (draggingBottle.userData.dragPlaneNum !== undefined)
        ? draggingBottle.userData.dragPlaneNum
        : draggingBottle.userData.plane;
      draggingBottle.userData.dragPlaneNum = undefined; // reset

      const nearest = findNearestSlotInPlane(finalPlane, draggingBottle.position.x, draggingBottle.position.z);
      if (nearest) {
        const newKey = `${nearest.plane}-${nearest.row}-${nearest.column}`;
        const occupant = slotOccupants[newKey];
        if (occupant && occupant !== draggingBottle) {
          const occupantData = occupant.userData;
          console.log(`Swapping occupant of slot ${newKey}`);
          const oldPlane = draggingBottle.userData.plane;
          const oldRow   = draggingBottle.userData.row;
          const oldCol   = draggingBottle.userData.column;
          const oldKey   = `${oldPlane}-${oldRow}-${oldCol}`;

          const oldSlot = planeLayouts[oldPlane].find(s => s.row === oldRow && s.column === oldCol);
          if (oldSlot) {
            occupant.position.set(oldSlot.x, oldSlot.y, oldSlot.z);
            occupant.userData.plane = oldPlane;
            occupant.userData.row   = oldRow;
            occupant.userData.column= oldCol;
            occupant.userData.initialY = oldSlot.y;
          }
          slotOccupants[oldKey] = occupant;

          draggingBottle.position.set(nearest.x, nearest.y, nearest.z);
          draggingBottle.userData.plane = nearest.plane;
          draggingBottle.userData.row   = nearest.row;
          draggingBottle.userData.column= nearest.column;
          draggingBottle.userData.initialY = nearest.y;
          slotOccupants[newKey] = draggingBottle;

          updateBottleSlotOnServer(draggingBottle.userData.notionData.id, nearest.plane, nearest.row, nearest.column);
          updateBottleSlotOnServer(occupantData.notionData.id, oldPlane, oldRow, oldCol);

        } else {
          draggingBottle.position.set(nearest.x, nearest.y, nearest.z);
          draggingBottle.userData.plane = nearest.plane;
          draggingBottle.userData.row   = nearest.row;
          draggingBottle.userData.column= nearest.column;
          draggingBottle.userData.initialY = nearest.y;
          slotOccupants[newKey] = draggingBottle;

          updateBottleSlotOnServer(draggingBottle.userData.notionData.id, nearest.plane, nearest.row, nearest.column);
        }
      } else {
        console.log("No suitable slot found in-plane. Reverting position.");
        const p = draggingBottle.userData;
        const oldSlot = planeLayouts[p.plane].find(s => s.row === p.row && s.column === p.column);
        if (oldSlot) {
          draggingBottle.position.set(oldSlot.x, p.initialY, oldSlot.z);
        }
      }

      // Hide the notices after releasing the bottle
      const dragBottleLabel = document.getElementById('dragBottleLabel');
      const dragSlotLabel = document.getElementById('dragSlotLabel');
      dragBottleLabel.style.display = 'none';
      dragSlotLabel.style.display = 'none';

      const dragPlaneMoveLabel = document.getElementById('dragPlaneMoveLabel');
      dragPlaneMoveLabel.style.display = 'none';

      draggingBottle = null;
    }

    // -------------------------------------------
    // Helper: findNearestSlot (all planes)
    // -------------------------------------------
    function findNearestSlot(x, z) {
      let nearest = null;
      let minDist = Infinity;
      for (const planeNum of Object.keys(planeLayouts)) {
        const slots = planeLayouts[planeNum];
        for (const s of slots) {
          const dx = s.x - x;
          const dz = s.z - z;
          const distSq = dx*dx + dz*dz;
          if (distSq < minDist) {
            minDist = distSq;
            nearest = s;
          }
        }
      }
      return nearest;
    }

    // -------------------------------------------
    // Helper: findNearestSlotInPlane
    // -------------------------------------------
    function findNearestSlotInPlane(plane, x, z) {
      let nearest = null;
      let minDist = Infinity;
      const slots = planeLayouts[plane];
      if (!slots) return null;
      for (const s of slots) {
        const dx = s.x - x;
        const dz = s.z - z;
        const distSq = dx*dx + dz*dz;
        if (distSq < minDist) {
          minDist = distSq;
          nearest = s;
        }
      }
      return nearest;
    }

    // -------------------------------------------
    // Update Notion field
    // -------------------------------------------
    async function updateBottleSlotOnServer(pageId, plane, row, column) {
      try {
        const resp = await fetch('/api/updateBottleSlot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pageId, plane, row, column })
        });
        if (!resp.ok) {
          console.error("Failed to update Notion for bottle:", pageId, resp.status);
        }
      } catch (err) {
        console.error("Error calling /api/updateBottleSlot:", err);
      }
    }

    async function updateBottleCapColorOnServer(pageId, capColor) {
      try {
        const resp = await fetch('/api/updateBottleCap', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ pageId, capColor })
        });
        if (!resp.ok) {
          console.error("Failed to update Notion for bottle cap color:", pageId, resp.status);
        }
      } catch (err) {
        console.error("Error calling /api/updateBottleCap:", err);
      }
    }

    function setCapColor(bottle, colorName) {
      const highlightables = bottle.userData.highlightables;
      if (!highlightables || highlightables.length < 2) return;
      const capEntry = highlightables[1];
      
      // Determine metallic properties based on cap color
      let metalness = 1.0;
      let roughness = 0.2;
      
      if (colorName === 'Gold') {
        metalness = 1.0;
        roughness = 0.1;
      } else if (colorName === 'Silver') {
        metalness = 0.95;
        roughness = 0.1;
      } else if (colorName === 'Black') {
        metalness = 0.8;
        roughness = 0.3;
      }
      
      // Update PBR material properties
      capEntry.mesh.material.metalness = metalness;
      capEntry.mesh.material.roughness = roughness;
      
      try {
        capEntry.mesh.material.color.setStyle(colorName);
        capEntry.originalColor.setStyle(colorName);
      } catch (err) {
        console.warn('Invalid color style, defaulting to gold');
        capEntry.mesh.material.color.setStyle('Gold');
        capEntry.originalColor.setStyle('Gold');
      }
      
      bottle.userData.notionData.capColor = colorName;
      // Update in Notion
      updateBottleCapColorOnServer(bottle.userData.notionData.id, colorName);
    }

    // -------------------------------------------
    // 8) Main animation loop
    // -------------------------------------------
    function animate() {
      requestAnimationFrame(animate);

      if (!dragMode) {
        clickableBottles.forEach(bottle => {
          if (bottle.userData.flying !== undefined) {
            const initialY = bottle.userData.initialY;
            const targetY  = initialY + FLY_OFFSET;

            if (bottle.userData.flying) {
              if (bottle.position.y < targetY) {
                bottle.position.y += MOVE_SPEED;
              }
              bottle.position.y = Math.min(bottle.position.y, targetY);

              // If flying, handle billboard animation
              if (bottle.userData.flying) {
                // If the bottle has a board, animate it slightly
                if (bottle.userData.boardMesh) {
                  // Make board gently float up and down
                  const now = Date.now();
                  const floatOffset = Math.sin(now * 0.002) * 2;
                  bottle.userData.boardMesh.position.y = BOTTLE_HEIGHT + 40 + floatOffset;
                  
                  // Always face the camera
                  bottle.userData.boardMesh.lookAt(camera.position);
                }
              // We'll define line3 with the slot position
              const line3 = `Col: ${bottle.userData.column}, Row: ${bottle.userData.row}`;
              // The 4th line can be set dynamically
              const line4 = bottle.userData.noticeLine4 || "";
  
                // If a board exists, remove it first so we can rebuild
                if (bottle.userData.boardMesh) {
                  bottle.remove(bottle.userData.boardMesh);
                  // Clean up old geometry/material
                  bottle.userData.boardMesh.geometry.dispose();
                  if (bottle.userData.boardMesh.material.map) {
                    bottle.userData.boardMesh.material.map.dispose();
                  }
                  bottle.userData.boardMesh.material.dispose();
                }
  
                // Create a new 4-line board
                bottle.userData.boardMesh = createBoardMesh(
                  bottle.userData.notionData.house || "Unknown House",
                  bottle.userData.notionData.name  || "No Name",
                  line3,
                  line4
                );
                // Attach board above the bottle with better positioning
                bottle.add(bottle.userData.boardMesh);
                bottle.userData.boardMesh.position.set(0, BOTTLE_HEIGHT + 40, 0);
  
                // Make the board always face the camera and update on render
                bottle.userData.boardMesh.lookAt(camera.position);
                
                // Add slight floating animation to make it more noticeable
                bottle.userData.boardAnimationOffset = Date.now() % 2000 / 2000;
  
              } else {
                // Not flying => remove board if present
                if (bottle.userData.boardMesh) {
                  bottle.remove(bottle.userData.boardMesh);
                  bottle.userData.boardMesh.geometry.dispose();
                  if (bottle.userData.boardMesh.material.map) {
                    bottle.userData.boardMesh.material.map.dispose();
                  }
                  bottle.userData.boardMesh.material.dispose();
                  bottle.userData.boardMesh = null;
                }
              }

            } else {
              if (bottle.position.y > initialY) {
                bottle.position.y -= MOVE_SPEED;
              }
              bottle.position.y = Math.max(bottle.position.y, initialY);

              // If the bottle is no longer flying, remove/destroy the board
              // If the bottle is no longer flying, remove/destroy the board
              if (bottle.userData.boardMesh) {
                bottle.remove(bottle.userData.boardMesh);
                bottle.userData.boardMesh.geometry.dispose();
                if (bottle.userData.boardMesh.material.map) {
                  bottle.userData.boardMesh.material.map.dispose();
                }
                bottle.userData.boardMesh.material.dispose();
                bottle.userData.boardMesh = null;
              }
            }
          }
        });
      }

      // Update lower-middle notice on screen
      const noticeBar = document.getElementById('noticeBar');
      if (activeBottle && activeBottle.userData.flying) {
        noticeBar.textContent = `${activeBottle.userData.notionData.name || 'Unknown'} @ column ${activeBottle.userData.column}, row ${activeBottle.userData.row}`;
        noticeBar.style.display = 'inline-block';
      } else {
        noticeBar.style.display = 'none';
      }

      // Render the scene directly since composer was removed
      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Update composer size as well
      if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    }

    // Check if filter box is visible
    function isFilterBoxVisible() {
      const filterBox = document.getElementById('filterBox');
      if (!filterBox) return false;
      const computedDisplay = window.getComputedStyle(filterBox).display;
      return computedDisplay !== 'none';
    }

    // Toggle the Filter Box
    function toggleFilterBox() {
      const filterBox = document.getElementById('filterBox');
      if (!filterBox) return;
      const computedDisplay = window.getComputedStyle(filterBox).display;
      if (computedDisplay === 'none') {
        filterBox.style.display = 'block';
        const filterInput = document.getElementById('filterInput');
        if (filterInput) {
          filterInput.value = '';
          filterInput.focus();
        }
      } else {
        filterBox.style.display = 'none';
      }
    }

    // Toggle the Help Window
    function toggleHelpWindow() {
      const helpWindow = document.getElementById('helpWindow');
      if (!helpWindow) return;
      const computedDisplay = window.getComputedStyle(helpWindow).display;
      if (computedDisplay === 'none' || computedDisplay === '') {
        helpWindow.style.display = 'block';
      } else {
        helpWindow.style.display = 'none';
      }
    }

    // Apply filter logic: highlight matching bottles
    function applyFilter(searchText) {

      // Helper to fold diacritics (normalize + strip)
      function fold(str) {
        return str
          .toLowerCase()
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '');
      }

      const trimmed = fold(searchText.trim());
      if (!trimmed) {
        // Reset highlight
        clickableBottles.forEach(bg => {
          const { highlightables } = bg.userData;
          if (!highlightables) return;
          const isSource = (bg === sourceBottle);
          const isTarget = (bg === targetBottle);
          highlightables.forEach(entry => {
            if (!isSource && !isTarget) {
              entry.mesh.material.color.copy(entry.originalColor);
            }
          });
          // Also revert flying state
          bg.userData.flying = false;
        });
        activeBottle = null;
        // Clear lastFilterMatches too
        lastFilterMatches = [];
        return;
      }

      const searchTokens = trimmed.split(/\s+/);

      // We'll track which bottles match
      const matchedBottles = [];

      // First reset flying state so we can do our logic anew
      clickableBottles.forEach(bg => {
        bg.userData.flying = false;
      });

      clickableBottles.forEach(bg => {
        const { notionData, highlightables } = bg.userData;
        if (!highlightables) return;

        const nameTokens = fold(notionData.name || '').split(/\s+/);
        const houseTokens = fold(notionData.house || '').split(/\s+/);
        const accordsTokens = (notionData.accords || [])
          .map(a => fold(a).split(/\s+/))
          .flat();
        const seasonTokens = (notionData.seasons || [])
          .map(s => fold(s).split(/\s+/))
          .flat();
        const typeTokens = fold(notionData.type || '').split(/\s+/);

        const bottleTokens = [
          ...nameTokens,
          ...houseTokens,
          ...accordsTokens,
          ...seasonTokens,
          ...typeTokens
        ];

        const foundAll = searchTokens.every(token => bottleTokens.includes(token));
        if (foundAll) {
          matchedBottles.push(bg);
        }

        const isSource = (bg === sourceBottle);
        const isTarget = (bg === targetBottle);
        highlightables.forEach(entry => {
          const mesh = entry.mesh;
          if (foundAll) {
            // set highlight color only if not source/target
            if (!isSource && !isTarget) {
              mesh.material.color.set(0xff0000);
            }
          } else {
            // revert color if not source/target
            if (!isSource && !isTarget) {
              mesh.material.color.copy(entry.originalColor);
            }
          }
        });
      });

      // Store matchedBottles so we can reference them in keydown ESC logic
      lastFilterMatches = matchedBottles;

      // If exactly 1 match, simulate a "click" on that bottle
      if (matchedBottles.length === 1) {
        const singleMatch = matchedBottles[0];
        // If there's a different active bottle, turn off flying
        if (activeBottle && activeBottle !== singleMatch) {
          activeBottle.userData.flying = false;
        }
        // If it's a different bottle than the current activeBottle, set it active & fly
        if (activeBottle !== singleMatch) {
          activeBottle = singleMatch;
          activeBottle.userData.flying = true;
        } else {
          // If it's the same bottle, toggle flying state
          activeBottle.userData.flying = !activeBottle.userData.flying;
        }
      } else {
        // More or less than one match => no auto-fly
        if (activeBottle) {
          activeBottle.userData.flying = false;
        }
        activeBottle = null;
      }
    }

    // Key listeners
    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();

      if (isFilterBoxVisible()) {
        if (key === 'escape') {
          if (lastFilterMatches.length === 1) {
            // Revert color but keep flying
            const singleMatch = lastFilterMatches[0];
            const { highlightables } = singleMatch.userData;
            highlightables.forEach((entry) => {
              entry.mesh.material.color.copy(entry.originalColor);
            });

            // Exit filter mode
            const filterInput = document.getElementById('filterInput');
            if (filterInput) {
              filterInput.value = '';
            }
            toggleFilterBox();
          } else {
            const filterInput = document.getElementById('filterInput');
            if (filterInput) {
              filterInput.value = '';
            }
            applyFilter('');
            toggleFilterBox();
          }
        }
        return;
      }

      // Toggle Help window with 'h' key (unless dragMode is on)
      if (!dragMode && key === 'h') {
        toggleHelpWindow();
        return;
      }

      if (key === 'd') {
        dragMode = !dragMode;
        const dragIndicator = document.getElementById('dragIndicator');
        if (dragMode) {
          dragIndicator.style.display = 'block';
          controls.enabled = false;
        } else {
          dragIndicator.style.display = 'none';
          controls.enabled = true;
        }
      } else if (!dragMode && key === 'f') {
        e.preventDefault();
        toggleFilterBox();
      } else if (dragMode && draggingBottle) {
        if (key === 'escape') {
          // Cancel drag
          cancelDrag();
        } else if (key === 'q') {
          // Move to plane above
          moveDraggingBottleToPlane(-1);
        } else if (key === 'a') {
          // Move to plane below
          moveDraggingBottleToPlane(1);
        }
      } else if (!dragMode) {
        // Normal mode additional keys
        if (key === 'escape') {
          // Press ESC in normal mode => reset source/target if any
          if (sourceBottle) revertMark(sourceBottle);
          if (targetBottle) revertMark(targetBottle);
          sourceBottle = null;
          targetBottle = null;
        } else if (key === '1') {
          // Mark activeBottle as source
          if (activeBottle && activeBottle.userData.flying) {
            markAsSource(activeBottle);
          }
        } else if (key === '2') {
          // Mark activeBottle as target
          if (activeBottle && activeBottle.userData.flying) {
            markAsTarget(activeBottle);
          }
        } else if (key === 's') {
          // Swap if both source and target are set
          if (sourceBottle && targetBottle) {
            swapBottlePositions(sourceBottle, targetBottle);
            revertMark(sourceBottle);
            revertMark(targetBottle);
            sourceBottle = null;
            targetBottle = null;
          }
        } else if (key === '3') {
          // Cap color = Gold
          if (activeBottle && activeBottle.userData.flying) {
            setCapColor(activeBottle, 'Gold');
          }
        } else if (key === '4') {
          // Cap color = Silver
          if (activeBottle && activeBottle.userData.flying) {
            setCapColor(activeBottle, 'Silver');
          }
        } else if (key === '5') {
          // Cap color = Black
          if (activeBottle && activeBottle.userData.flying) {
            setCapColor(activeBottle, 'Black');
          }
        }
      }

      function cancelDrag() {
        // revert to old position
        const p = draggingBottle.userData;
        const oldPlane = p.plane;
        const oldRow = p.row;
        const oldCol = p.column;
        const oldSlot = planeLayouts[`${oldPlane}`].find(s => s.row === oldRow && s.column === oldCol);
        if (oldSlot) {
          draggingBottle.position.set(oldSlot.x, p.initialY, oldSlot.z);
          slotOccupants[`${oldPlane}-${oldRow}-${oldCol}`] = draggingBottle;
        }
        // Hide drag labels
        const dragBottleLabel = document.getElementById('dragBottleLabel');
        const dragSlotLabel = document.getElementById('dragSlotLabel');
        dragBottleLabel.style.display = 'none';
        dragSlotLabel.style.display = 'none';

        draggingBottle = null;
      }

      function moveDraggingBottleToPlane(delta) {
        if (!draggingBottle) return;
        
        const p = draggingBottle.userData;
        const oldPlane = (p.dragPlaneNum !== undefined) ? p.dragPlaneNum : p.plane;
        let newPlane = oldPlane + delta;
        if (newPlane < 1) newPlane = 1;
        if (newPlane > 4) newPlane = 4;
        
        // Store this plane choice but do not finalize occupant changes until mouse up
        p.dragPlaneNum = newPlane;
        
        // Adjust the dragPlane so the user can visually drag in the new plane's Y
        const planeSlots = planeLayouts[newPlane];
        if (planeSlots && planeSlots.length > 0) {
          const planeY = planeSlots[0].y;
          dragPlane.constant = -planeY;
          draggingBottle.position.y = planeY;
          p.initialY = planeY;
        }

        const dragPlaneMoveLabel = document.getElementById('dragPlaneMoveLabel');
        dragPlaneMoveLabel.style.display = 'block';
        if (delta < 0) {
          dragPlaneMoveLabel.innerText = "Move up";
        } else {
          dragPlaneMoveLabel.innerText = "Move down";
        }
      }
    });

    window.addEventListener('keyup', (e) => {
      if (dragMode && (e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 'q')) {
        const dragPlaneMoveLabel = document.getElementById('dragPlaneMoveLabel');
        dragPlaneMoveLabel.style.display = 'none';
      }
    });
  </script>

  <!-- Hidden by default in CSS -->
  <div id="filterBox">
    <h3>Filter</h3>
    <label for="filterInput">Filter text:</label>
    <input id="filterInput" type="text" placeholder="Enter text to filter bottles..." />
  </div>

  <!-- Help window, hidden by default -->
  <div id="helpWindow">
    <h3>Help</h3>
    <ul>
      <li><strong>d</strong>: Toggle Drag Mode</li>
      <li><strong>f</strong>: Toggle Filter Mode</li>
      <li><strong>h</strong>: Toggle this Help Window</li>
      <li><strong>q</strong> / <strong>a</strong>: Move dragged bottle to plane above/below (Drag Mode)</li>
      <li><strong>1</strong>: Mark flying bottle as Source (Green) in Normal mode</li>
      <li><strong>2</strong>: Mark flying bottle as Target (Blue) in Normal mode</li>
      <li><strong>3</strong>: Set cap color to Gold (Normal mode + flying bottle)</li>
      <li><strong>4</strong>: Set cap color to Silver (Normal mode + flying bottle)</li>
      <li><strong>5</strong>: Set cap color to Black (Normal mode + flying bottle)</li>
      <li><strong>s</strong>: Swap Source & Target (Normal mode only)</li>
      <li><strong>ESC</strong>: Close Filter box/cancel drag or reset Source/Target in Normal mode</li>
    </ul>
  </div>
<div id="helpHint">
  <span>H for Help</span>
  <span id="noticeBar" style="margin-left: 12px; display:none;"></span>
</div>
</body>
</html>