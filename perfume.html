<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Perfume Racks with Notion Data</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Three.js and OrbitControls -->
  <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // -------------------------------------------
    // Global Scene Variables
    // -------------------------------------------
    let scene, camera, renderer, controls;
    const raycaster = new THREE.Raycaster();
    const mouse     = new THREE.Vector2();

    // We'll store all clickable bottle meshes here:
    const clickableBottles = [];

    // If we want a bottle to “fly” up on click:
    const MOVE_SPEED  = 2;
    const FLY_OFFSET  = 32;  // how far bottle flies up
    let activeBottle  = null;

    // Dimensions
    const SLOT_WIDTH_DEPTH = 15;   // each slot cell width & depth
    const BOTTLE_HEIGHT    = 64;

    // The config object from /api/config
    let config = {
      platoonA1: "",
      platoonA2: "",
      platoonA3: "",
      platoonA4: "",
      planeP1:   "",
      planeP2:   "",
      planeVerticalOffset: "2",
      offsetPlatoon:       "1",
      capColorDefault:     "Gold"
    };

    // We'll parse environment-based definitions the same as on the server
    const platoons = {}; // e.g. platoons["A1"] = { racks, rows, slots }

    // A lookup: planeLayouts[planeNumber] = array of { plane, row, column, x, y, z }
    const planeLayouts = {};

    // -------------------------------------------
    // 0) On window load, fetch config & data, build scene
    // -------------------------------------------
    window.addEventListener('load', async () => {
      await fetchConfig();
      parsePlatoonConfigs(); // fill "platoons" with data from config

      initScene();

      // Build the racks visually (no bottles in them yet)
      buildAllPlanes();

      // Now fetch the Notion data (including plane/row/col)
      const notionBottles = await fetchAllNotionBottles();

      // For each bottle from Notion, place it in the correct slot
      notionBottles.forEach(bData => {
        createBottleFromNotion(bData);
      });

      animate();
    });

    // -------------------------------------------
    // 1) Fetch config from server
    // -------------------------------------------
    async function fetchConfig() {
      try {
        const response = await fetch('/api/config');
        if (!response.ok) {
          throw new Error('Failed to load config');
        }
        config = await response.json();
      } catch (err) {
        console.error('Error fetching config:', err);
      }
    }

    // -------------------------------------------
    // 2) Parse environment-based platoon definitions
    // -------------------------------------------
    function parsePlatoonConfigs() {
      platoons.A1 = parsePlatoonDefinition(config.platoonA1);
      platoons.A2 = parsePlatoonDefinition(config.platoonA2);
      platoons.A3 = parsePlatoonDefinition(config.platoonA3);
      platoons.A4 = parsePlatoonDefinition(config.platoonA4);
    }

    // E.g. "platoon(6(4,6))" => { racks:6, rows:4, slots:6 }
    function parsePlatoonDefinition(str) {
      const match = /^platoon\((\d+)\((\d+),(\d+)\)\)$/.exec((str || "").trim());
      if (!match) {
        console.warn("Invalid platoon definition:", str);
        return { racks: 0, rows: 0, slots: 0 };
      }
      return {
        racks: parseInt(match[1]),
        rows:  parseInt(match[2]),
        slots: parseInt(match[3])
      };
    }

    // E.g. "A1xA2" => ["A1", "A2"]
    function parsePlaneDefinition(str) {
      return (str || "").split('x').map(s => s.trim());
    }

    // -------------------------------------------
    // 3) Initialize Scene, Camera, Controls
    // -------------------------------------------
    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(150, 100, 200);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 50, 0);
      controls.update();

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(10, 20, 10);
      scene.add(directionalLight);

      // Event Listeners
      renderer.domElement.addEventListener('mousedown', onDocumentMouseDown);
      window.addEventListener('resize', onWindowResize);
    }

    // -------------------------------------------
    // 4) Build planes & racks (just the shelves)
    // -------------------------------------------
    function buildAllPlanes() {
      // We'll handle up to 4 planes, because your .env suggests PLANE_P1..PLANE_P4.
      // For each plane X that exists, parse plane definition, build the geometry.
      // Also store a "slot lookup" => exact X/Z offset for row, column.

      // If planeVerticalOffset => how far down each plane sits from the previous
      let currentPlaneY = 0; // y offset for plane #1

      for (let planeNumber = 1; planeNumber <= 4; planeNumber++) {
        // E.g. "planeP1" from config
        const planeKey = `planeP${planeNumber}`;
        if (!config[planeKey]) {
          continue; // skip if not defined
        }
        // Parse e.g. "A1xA2" => ["A1","A2"]
        const platoonIds = parsePlaneDefinition(config[planeKey]);
        if (!platoonIds.length) {
          continue;
        }

        // Make a group for the entire plane
        const planeGroup = new THREE.Group();
        planeGroup.position.set(0, currentPlaneY, 0);
        scene.add(planeGroup);

        let platoonZ = 0;
        planeLayouts[planeNumber] = [];

        // For each platoon ID in this plane
        platoonIds.forEach(platoonId => {
          const p = platoons[platoonId];
          if (!p) {
            console.warn("No definition found for platoon:", platoonId);
            return;
          }
          const { racks, rows, slots } = p;

          // Create a "platoonGroup" to hold the racks
          const platoonGroup = new THREE.Group();
          platoonGroup.position.set(0, 0, platoonZ);
          planeGroup.add(platoonGroup);

          // Build each rack side-by-side in X
          for (let r = 0; r < racks; r++) {
            const rackGroup = createSteppedRack(rows, slots);
            // offset in X
            const rackWidth = slots * SLOT_WIDTH_DEPTH;
            rackGroup.position.x = r * rackWidth;
            platoonGroup.add(rackGroup);

            // For each row & column in this rack, store a slot => (x,y,z)
            for (let row = 0; row < rows; row++) {
              for (let col = 0; col < slots; col++) {
                // compute the actual 3D position:
                const slotCenterX = - (slots * SLOT_WIDTH_DEPTH) / 2
                                    + col * SLOT_WIDTH_DEPTH
                                    + SLOT_WIDTH_DEPTH / 2
                                    + rackGroup.position.x; // offset by rack

                // row centerZ
                const totalDepth  = rows * SLOT_WIDTH_DEPTH;
                const rowDepth    = totalDepth / rows;
                const slotCenterZ = totalDepth / 2
                                    - row * rowDepth
                                    - rowDepth / 2
                                    + platoonGroup.position.z; // offset by platoonZ

                // vertical shelf top
                const wallThickness = 0.1;
                const stepY         = (BOTTLE_HEIGHT / 2) * 0.3; // ~9.6
                const shelfTop      = wallThickness + (stepY * row) + wallThickness;

                // final world coords (planeGroup offset in Y not included yet)
                const localX = slotCenterX;
                const localY = shelfTop;
                const localZ = slotCenterZ;

                // But planeGroup’s position.y = currentPlaneY
                const worldX = localX;
                const worldY = currentPlaneY + localY;
                const worldZ = localZ;

                // Store this in planeLayouts for quick lookup
                planeLayouts[planeNumber].push({
                  plane: planeNumber,
                  row,
                  column: (r * slots) + col, // offset columns by rack index
                  x: worldX,
                  y: worldY,
                  z: worldZ
                });
              }
            }
          }

          // Move the next platoon behind in Z
          const offsetCount      = parseFloat(config.offsetPlatoon) || 1;
          const singleRackDepth  = rows * SLOT_WIDTH_DEPTH;
          const platoonDepth     = singleRackDepth;
          platoonZ -= offsetCount * 2 * platoonDepth;
        });

        // Move the next plane downward
        const planeVerticalOffset = parseFloat(config.planeVerticalOffset) || 2;
        // We'll estimate one typical "rack depth" for the offset if needed
        // but you can refine as you like:
        currentPlaneY -= planeVerticalOffset * BOTTLE_HEIGHT; // some logic
      }
    }

    /**
     * Create only the stepped geometry for a single rack,
     * WITHOUT automatically placing any bottles.
     */
    function createSteppedRack(numRows, numSlots) {
      const group = new THREE.Group();
      const totalWidth = numSlots * SLOT_WIDTH_DEPTH;
      const totalDepth = numRows * SLOT_WIDTH_DEPTH;
      const rowHeight  = BOTTLE_HEIGHT / 2; // 32
      const wallThickness = 0.1;
      const stepY     = rowHeight * 0.3; // ~9.6
      const baseY     = wallThickness / 2;

      const mat = new THREE.MeshPhongMaterial({
        color: 0xcccccc,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });

      // Utility for row center
      const rowDepth = totalDepth / numRows;
      function rowCenterZ(i) {
        return totalDepth/2 - rowDepth/2 - rowDepth*i;
      }

      // Build each row
      for (let i = 0; i < numRows; i++) {
        const rowBaseY = baseY + stepY * i;
        const centerZ  = rowCenterZ(i);

        // floor
        const floorGeom = new THREE.BoxGeometry(totalWidth, wallThickness, rowDepth);
        const floorMesh = new THREE.Mesh(floorGeom, mat);
        floorMesh.position.set(0, rowBaseY, centerZ);
        group.add(floorMesh);

        // vertical dividers
        for (let j = 1; j < numSlots; j++) {
          const dividerGeom = new THREE.BoxGeometry(wallThickness, rowHeight, rowDepth - 2*wallThickness);
          const divider     = new THREE.Mesh(dividerGeom, mat);
          const xPos        = -totalWidth/2 + (totalWidth/numSlots)*j;
          divider.position.set(xPos, rowBaseY + wallThickness + rowHeight/2, centerZ);
          group.add(divider);
        }

        // side walls
        const sideGeom   = new THREE.BoxGeometry(wallThickness, rowHeight, rowDepth);
        const leftWall   = new THREE.Mesh(sideGeom, mat);
        leftWall.position.set(
          -totalWidth/2 + wallThickness/2,
          rowBaseY + wallThickness + rowHeight/2,
          centerZ
        );
        group.add(leftWall);

        const rightWall  = new THREE.Mesh(sideGeom, mat);
        rightWall.position.set(
          totalWidth/2 - wallThickness/2,
          rowBaseY + wallThickness + rowHeight/2,
          centerZ
        );
        group.add(rightWall);
      }

      // front wall (beveled)
      const frontWallGeom = createBeveledWall(totalWidth, rowHeight, wallThickness, 0.2, 0.05);
      const frontWall     = new THREE.Mesh(frontWallGeom, mat);
      frontWall.rotation.y = Math.PI;
      frontWall.position.set(0, baseY, totalDepth/2);
      group.add(frontWall);

      // back wall (beveled, taller if multiple rows)
      const extraHeight  = (numRows - 1) * stepY;
      const backWallGeom = createBeveledWall(totalWidth, rowHeight + extraHeight, wallThickness, 0.2, 0.05);
      const backWall     = new THREE.Mesh(backWallGeom, mat);
      backWall.position.set(0, baseY, -totalDepth/2);
      group.add(backWall);

      // shared walls between row steps
      for (let i = 0; i < numRows - 1; i++) {
        const lowerY = baseY + stepY*(i+1);
        const upperY = baseY + stepY*i + rowHeight;
        const overlapHeight = upperY - lowerY;
        const boundaryZ = rowCenterZ(i) - rowDepth/2 + wallThickness/2;

        const sharedGeom = new THREE.BoxGeometry(totalWidth, overlapHeight, wallThickness);
        const sharedWall = new THREE.Mesh(sharedGeom, mat);
        sharedWall.position.set(0, lowerY + overlapHeight/2, boundaryZ);
        group.add(sharedWall);
      }

      return group;
    }

    // Utility: create beveled wall geometry
    function createBeveledWall(width, height, depth, bevelSize, bevelThickness) {
      const shape = new THREE.Shape();
      shape.moveTo(-width/2, 0);
      shape.lineTo(width/2, 0);
      shape.lineTo(width/2, height);
      shape.lineTo(-width/2, height);
      shape.lineTo(-width/2, 0);

      const extrudeSettings = {
        steps: 1,
        depth: depth,
        bevelEnabled: true,
        bevelThickness: bevelThickness,
        bevelSize: bevelSize,
        bevelSegments: 1
      };
      return new THREE.ExtrudeGeometry(shape, extrudeSettings);
    }

    // -------------------------------------------
    // 5) Fetch the Notion Bottles (plane/row/col)
    // -------------------------------------------
    async function fetchAllNotionBottles() {
      try {
        const response = await fetch('/api/bottles');
        if (!response.ok) {
          throw new Error(`Failed to fetch /api/bottles. Status = ${response.status}`);
        }
        const data = await response.json(); // array of { id, name, plane, row, column, ... }
        return data;
      } catch (err) {
        console.error('fetchAllNotionBottles error:', err);
        return [];
      }
    }

    // -------------------------------------------
    // 6) Create Bottles in the Correct Position
    // -------------------------------------------
    function createBottleFromNotion(bData) {
      const { plane, row, column, name, capColor } = bData;

      // Find the matching slot in planeLayouts[plane]
      if (!planeLayouts[plane]) {
        console.warn(`No plane layout found for plane=${plane}`);
        return;
      }

      // Find the matching (row, column) among the stored slot positions
      const slot = planeLayouts[plane].find(s => s.row === row && s.column === column);
      if (!slot) {
        console.warn(`No slot found for plane=${plane}, row=${row}, column=${column}`);
        return;
      }

      // Now create the 3D geometry at slot.x, slot.y, slot.z
      // (We can reuse your existing "bottle geometry" code)
      const bottleGroup = new THREE.Group();

      // Transparent bottle
      const bottleWidth  = 10;
      const bottleDepth  = 10;
      const bottleHeight = BOTTLE_HEIGHT;
      const capHeight    = 15;
      const capRadius    = 5;

      // Bottle body
      const bottleGeo = new THREE.BoxGeometry(bottleWidth, bottleHeight, bottleDepth);
      const bottleMat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        roughness: 0,
        metalness: 0,
        transmission: 1,
        thickness: 1,
        transparent: true,
        opacity: 0.5
      });
      const bottleMesh = new THREE.Mesh(bottleGeo, bottleMat);
      bottleMesh.position.set(0, bottleHeight/2, 0);

      // Label
      const labelWidth  = bottleWidth;
      const labelHeight = bottleHeight / 2;
      const labelGeo = new THREE.PlaneGeometry(labelWidth, labelHeight);
      const labelTexture = createLabelTexture(name || "(No Name)");
      const labelMat = new THREE.MeshBasicMaterial({
        map: labelTexture,
        side: THREE.DoubleSide,
        transparent: true
      });
      const labelMesh = new THREE.Mesh(labelGeo, labelMat);
      labelMesh.position.set(0, 0, bottleDepth/2 + 0.01);
      bottleMesh.add(labelMesh);

      // Cap
      const capGeo = new THREE.CylinderGeometry(capRadius, capRadius, capHeight, 32);
      const capMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
      if (capColor) {
        try {
          capMat.color.setStyle(capColor);
        } catch {
          capMat.color.set(0xffd700); // fallback to gold
        }
      }
      const capMesh = new THREE.Mesh(capGeo, capMat);
      capMesh.position.set(0, bottleHeight + capHeight/2, 0);

      // Combine
      bottleGroup.add(bottleMesh);
      bottleGroup.add(capMesh);

      // Place in final position
      bottleGroup.position.set(slot.x, slot.y, slot.z);

      // Store some userData for fly-up effect
      bottleGroup.userData.initialY = bottleGroup.position.y;
      bottleGroup.userData.flying   = false;
      bottleGroup.userData.notionData = bData; // keep the full record

      // Track as clickable
      clickableBottles.push(bottleGroup);
      scene.add(bottleGroup);
    }

    // Utility: label texture
    function createLabelTexture(text) {
      const canvas  = document.createElement('canvas');
      canvas.width  = 256;
      canvas.height = 819;
      const ctx     = canvas.getContext('2d');

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.font         = "60px Arial";
      ctx.fillStyle    = "#000000";
      ctx.textAlign    = "center";
      ctx.textBaseline = "middle";

      // rotate -90 degrees
      ctx.save();
      ctx.translate(0, canvas.height);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(text, canvas.height / 2, canvas.width / 2);
      ctx.restore();

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    // -------------------------------------------
    // 7) Interaction (fly up on click)
    // -------------------------------------------
    function onDocumentMouseDown(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableBottles, true);

      if (intersects.length > 0) {
        let clickedGroup = intersects[0].object;
        // bubble up to the bottleGroup
        while (clickedGroup.parent && !clickableBottles.includes(clickedGroup)) {
          clickedGroup = clickedGroup.parent;
        }
        // If we have an active bottle, drop it first
        if (activeBottle && activeBottle !== clickedGroup) {
          activeBottle.userData.flying = false;
        }
        activeBottle = clickedGroup;
        activeBottle.userData.flying = true;
      } else {
        // If we clicked empty space, drop the active bottle
        if (activeBottle) {
          activeBottle.userData.flying = false;
        }
      }
    }

    // -------------------------------------------
    // 8) Main animation loop
    // -------------------------------------------
    function animate() {
      requestAnimationFrame(animate);

      if (activeBottle) {
        const initialY = activeBottle.userData.initialY;
        const targetY  = initialY + FLY_OFFSET;
        if (activeBottle.userData.flying) {
          // fly up
          if (activeBottle.position.y < targetY) {
            activeBottle.position.y += MOVE_SPEED;
            if (activeBottle.position.y > targetY) {
              activeBottle.position.y = targetY;
            }
          }
        } else {
          // drop down
          if (activeBottle.position.y > initialY) {
            activeBottle.position.y -= MOVE_SPEED;
            if (activeBottle.position.y < initialY) {
              activeBottle.position.y = initialY;
            }
          } else {
            activeBottle = null;
          }
        }
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
