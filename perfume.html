<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Perfume Racks with Notion Data</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Three.js and OrbitControls -->
  <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // -------------------------------------------
    // Global Scene Variables
    // -------------------------------------------
    let scene, camera, renderer, controls;
    const raycaster = new THREE.Raycaster();
    const mouse     = new THREE.Vector2();

    // We'll store all clickable bottle meshes here:
    const clickableBottles = [];

    // If we want a bottle to “fly” up on click:
    const MOVE_SPEED  = 2;
    const FLY_OFFSET  = 32;  // how far bottle flies up
    let activeBottle  = null;

    // Dimensions
    const SLOT_WIDTH_DEPTH = 15;   // each slot cell width & depth
    const BOTTLE_HEIGHT    = 64;

    // The config object from /api/config
    let config = {
      rackR1: "",
      rackR2: "",
      rackR3: "",
      rackR4: "",
      planeP1: "",
      planeP2: "",
      planeVerticalOffset: "2",
      offsetRack: "1",
      capColorDefault: "Gold"
    };

    // We'll store the parsed racks here, e.g. racks["R1"] = { rows, columns }
    const racks = {};

    // A lookup: planeLayouts[planeNumber] = array of { plane, row, column, x, y, z }
    const planeLayouts = {};

    // -------------------------------------------
    // On window load, fetch config & data, then build scene
    // -------------------------------------------
    window.addEventListener('load', async () => {
      await fetchConfig();
      parseRackConfigs();

      initScene();
      buildAllPlanes();

      // Now fetch the Notion data
      const notionBottles = await fetchAllNotionBottles();

      // Place each bottle
      notionBottles.forEach(bData => {
        createBottleFromNotion(bData);
      });

      animate();
    });

    // -------------------------------------------
    // 1) Fetch config from server
    // -------------------------------------------
    async function fetchConfig() {
      try {
        const response = await fetch('/api/config');
        if (!response.ok) {
          throw new Error('Failed to load config');
        }
        config = await response.json();
      } catch (err) {
        console.error('Error fetching config:', err);
      }
    }

    // -------------------------------------------
    // 2) Parse environment-based rack definitions
    // e.g. RACK_R1="(4,6)" => { rows:4, columns:6 }
    // We'll store them in racks["R1"] = { rows, columns }
    // Then the plane definitions: e.g. "R1xR2"
    // We'll unify them in row dimension.
    // -------------------------------------------
    function parseRackConfigs() {
      parseSingleRack("R1", config.rackR1);
      parseSingleRack("R2", config.rackR2);
      parseSingleRack("R3", config.rackR3);
      parseSingleRack("R4", config.rackR4);
    }

    function parseSingleRack(rackId, definition) {
      // definition is something like "(4,6)"
      const match = /^\((\d+),(\d+)\)$/.exec((definition || "").trim());
      if (!match) {
        racks[rackId] = { rows: 0, columns: 0 };
      } else {
        racks[rackId] = {
          rows: parseInt(match[1], 10),
          columns: parseInt(match[2], 10)
        };
      }
    }

    // e.g. "R1xR2" => ["R1","R2"]
    function parsePlaneDefinition(str) {
      return (str || "").split('x').map(s => s.trim());
    }

    // -------------------------------------------
    // 3) Initialize Scene, Camera, Controls
    // -------------------------------------------
    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        2000
      );
      camera.position.set(150, 100, 200);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 50, 0);
      controls.update();

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight.position.set(10, 20, 10);
      scene.add(directionalLight);

      // Event Listeners
      renderer.domElement.addEventListener('mousedown', onDocumentMouseDown);
      window.addEventListener('resize', onWindowResize);
    }

    // -------------------------------------------
    // 4) Build planes & racks (just the shelves)
    // We'll parse PLANE_P1..P4. Each plane can have multiple racks, stacked in row dimension.
    // Then we place planes one after another in the negative Y direction using planeVerticalOffset.
    // The row dimension is mapped to Z, the column dimension is mapped to X.
    // -------------------------------------------
    function buildAllPlanes() {
      const planeKeys = ["planeP1","planeP2","planeP3","planeP4"];
      let currentPlaneY = 0; // downward offset for planes
      console.log("[DEBUG] config:", config);

      planeKeys.forEach((planeKey, index) => {
        const definition = config[planeKey];
        if (!definition) return;

        const planeNumber = index + 1;
        const rackIds = parsePlaneDefinition(definition);
        if (!rackIds || !rackIds.length) return;

        const planeGroup = new THREE.Group();
        planeGroup.position.set(0, currentPlaneY, 0);
        scene.add(planeGroup);

        planeLayouts[planeNumber] = [];

        let rowIndexBase = 0;
        let rowStackOffset = 0;
        const offsetRack = parseFloat(config.offsetRack) || 1;

        rackIds.forEach(rackId => {
          const rDef = racks[rackId] || { rows:0, columns:0 };
          if (rDef.rows <= 0 || rDef.columns <= 0) {
            console.warn("No valid definition for rackId =", rackId);
            return;
          }

          // Create rack geometry
          const rows    = rDef.rows;
          const columns = rDef.columns;
          const rackGroup = createSteppedRack(rows, columns);

          // We stack racks by row dimension => place them behind the previous in Z
          const rackDepth = rows * SLOT_WIDTH_DEPTH;
          rackGroup.position.z = -rowStackOffset;
          planeGroup.add(rackGroup);

          // For each row & column in this rack, record the world coords
          for (let row = 0; row < rows; row++) {
            for (let col = 0; col < columns; col++) {
              // center X for column
              const totalWidth = columns * SLOT_WIDTH_DEPTH;
              const slotCenterX = - (totalWidth / 2)
                                  + col * SLOT_WIDTH_DEPTH
                                  + SLOT_WIDTH_DEPTH / 2;

              // center Z for row (in local coords of this rack)
              const rowDepth   = rackDepth / rows; // e.g. 15
              const slotCenterZ = (rackDepth / 2)
                                  - row * rowDepth
                                  - (rowDepth / 2);

              // The entire rackGroup is offset by rackGroup.position.z
              const worldX = slotCenterX;
              const worldY = currentPlaneY + 0; // we place shelves at about y=0 inside the group
              const worldZ = planeGroup.position.z + rackGroup.position.z + slotCenterZ;

              planeLayouts[planeNumber].push({
                plane: planeNumber,
                row: rowIndexBase + row + 1,
                column: col + 1,
                x: worldX,
                y: worldY,
                z: worldZ
              });
            }
          }

          // Move rowIndexBase for the next rack
          rowIndexBase += rDef.rows;

          // Move stack offset for the next rack
          rowStackOffset += rackDepth;
          rowStackOffset += offsetRack * rackDepth; // extra gap between racks
        });

        const maxRow = Math.max(...planeLayouts[planeNumber].map(s => s.row));
        const maxCol = Math.max(...planeLayouts[planeNumber].map(s => s.column));
        console.log(`[DEBUG] Plane #${planeNumber} has maxRow=${maxRow}, maxCol=${maxCol}`);

        // Next plane is offset downward in Y
        const planeVerticalOffset = parseFloat(config.planeVerticalOffset) || 2;
        // E.g. move the plane in negative Y by planeVerticalOffset * BOTTLE_HEIGHT
        currentPlaneY -= planeVerticalOffset * BOTTLE_HEIGHT;
      });
    }

    /**
     * Create a single stepped rack geometry for (numRows, numColumns).
     * We'll keep the logic similar to the old code, but ignoring platoons entirely.
     * The row dimension is local Z, the column dimension is local X.
     */
    function createSteppedRack(numRows, numColumns) {
      const group = new THREE.Group();
      const totalWidth = numColumns * SLOT_WIDTH_DEPTH;
      const totalDepth = numRows * SLOT_WIDTH_DEPTH;
      const rowHeight  = BOTTLE_HEIGHT / 2; // 32
      const wallThickness = 0.1;
      const stepY     = rowHeight * 0.3; // e.g. ~9.6
      const baseY     = wallThickness / 2;

      const mat = new THREE.MeshPhongMaterial({
        color: 0xcccccc,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });

      // Utility for row center
      const rowDepth = totalDepth / numRows;
      function rowCenterZ(i) {
        return totalDepth / 2 - rowDepth / 2 - rowDepth * i;
      }

      // Build each row
      for (let i = 0; i < numRows; i++) {
        const rowBaseY = baseY + stepY * i;
        const centerZ  = rowCenterZ(i);

        // floor
        const floorGeom = new THREE.BoxGeometry(totalWidth, wallThickness, rowDepth);
        const floorMesh = new THREE.Mesh(floorGeom, mat);
        floorMesh.position.set(0, rowBaseY, centerZ);
        group.add(floorMesh);

        // vertical dividers (columns)
        for (let j = 1; j < numColumns; j++) {
          const dividerGeom = new THREE.BoxGeometry(wallThickness, rowHeight, rowDepth - 2*wallThickness);
          const divider     = new THREE.Mesh(dividerGeom, mat);
          const xPos        = -totalWidth/2 + (totalWidth/numColumns)*j;
          divider.position.set(xPos, rowBaseY + wallThickness + rowHeight/2, centerZ);
          group.add(divider);
        }

        // side walls
        const sideGeom   = new THREE.BoxGeometry(wallThickness, rowHeight, rowDepth);
        const leftWall   = new THREE.Mesh(sideGeom, mat);
        leftWall.position.set(
          -totalWidth/2 + wallThickness/2,
          rowBaseY + wallThickness + rowHeight/2,
          centerZ
        );
        group.add(leftWall);

        const rightWall  = new THREE.Mesh(sideGeom, mat);
        rightWall.position.set(
          totalWidth/2 - wallThickness/2,
          rowBaseY + wallThickness + rowHeight/2,
          centerZ
        );
        group.add(rightWall);
      }

      // front wall (beveled)
      const frontWallGeom = createBeveledWall(totalWidth, rowHeight, wallThickness, 0.2, 0.05);
      const frontWall     = new THREE.Mesh(frontWallGeom, mat);
      frontWall.rotation.y = Math.PI;
      frontWall.position.set(0, baseY, totalDepth/2);
      group.add(frontWall);

      // back wall (beveled, taller if multiple rows)
      const extraHeight  = (numRows - 1) * stepY;
      const backWallGeom = createBeveledWall(totalWidth, rowHeight + extraHeight, wallThickness, 0.2, 0.05);
      const backWall     = new THREE.Mesh(backWallGeom, mat);
      backWall.position.set(0, baseY, -totalDepth/2);
      group.add(backWall);

      // shared walls between row steps
      for (let i = 0; i < numRows - 1; i++) {
        const lowerY = baseY + stepY*(i+1);
        const upperY = baseY + stepY*i + rowHeight;
        const overlapHeight = upperY - lowerY;
        const boundaryZ = rowCenterZ(i) - rowDepth/2 + wallThickness/2;

        const sharedGeom = new THREE.BoxGeometry(totalWidth, overlapHeight, wallThickness);
        const sharedWall = new THREE.Mesh(sharedGeom, mat);
        sharedWall.position.set(0, lowerY + overlapHeight/2, boundaryZ);
        group.add(sharedWall);
      }

      return group;
    }

    // Utility: create beveled wall geometry
    function createBeveledWall(width, height, depth, bevelSize, bevelThickness) {
      const shape = new THREE.Shape();
      shape.moveTo(-width/2, 0);
      shape.lineTo(width/2, 0);
      shape.lineTo(width/2, height);
      shape.lineTo(-width/2, height);
      shape.lineTo(-width/2, 0);

      const extrudeSettings = {
        steps: 1,
        depth: depth,
        bevelEnabled: true,
        bevelThickness: bevelThickness,
        bevelSize: bevelSize,
        bevelSegments: 1
      };
      return new THREE.ExtrudeGeometry(shape, extrudeSettings);
    }

    // -------------------------------------------
    // 5) Fetch the Notion Bottles (plane/row/col)
    // -------------------------------------------
    async function fetchAllNotionBottles() {
      try {
        const response = await fetch('/api/bottles');
        if (!response.ok) {
          throw new Error(`Failed to fetch /api/bottles. Status = ${response.status}`);
        }
        const data = await response.json(); // array of { id, name, plane, row, column, ... }
        return data;
      } catch (err) {
        console.error('fetchAllNotionBottles error:', err);
        return [];
      }
    }

    // -------------------------------------------
    // 6) Create Bottles in the Correct Position
    // We'll use planeLayouts[plane] to find a slot with matching row & column.
    // If not found, we skip. (Might happen if the Notion data is out of range.)
    // -------------------------------------------
    function createBottleFromNotion(bData) {
      const { plane, row, column, name, capColor } = bData;

      if (!planeLayouts[plane]) {
        console.warn(`No plane layout found for plane=${plane}`);
        return;
      }

      // Find a matching row/column
      const slot = planeLayouts[plane].find(s => s.row === row && s.column === column);
      if (!slot) {
        console.warn(`No slot found for plane=${plane}, row=${row}, column=${column}`);
        return;
      }

      // Create the 3D geometry
      const bottleGroup = new THREE.Group();

      const bottleWidth  = 10;
      const bottleDepth  = 10;
      const bottleHeight = BOTTLE_HEIGHT;
      const capHeight    = 15;
      const capRadius    = 5;

      // Bottle body
      const bottleGeo = new THREE.BoxGeometry(bottleWidth, bottleHeight, bottleDepth);
      const bottleMat = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        roughness: 0,
        metalness: 0,
        transmission: 1,
        thickness: 1,
        transparent: true,
        opacity: 0.5
      });
      const bottleMesh = new THREE.Mesh(bottleGeo, bottleMat);
      bottleMesh.position.set(0, bottleHeight/2, 0);

      // Label
      const labelWidth  = bottleWidth;
      const labelHeight = bottleHeight / 2;
      const labelGeo = new THREE.PlaneGeometry(labelWidth, labelHeight);
      const labelTexture = createLabelTexture(name || "(No Name)");
      const labelMat = new THREE.MeshBasicMaterial({
        map: labelTexture,
        side: THREE.DoubleSide,
        transparent: true
      });
      const labelMesh = new THREE.Mesh(labelGeo, labelMat);
      labelMesh.position.set(0, 0, bottleDepth/2 + 0.01);
      bottleMesh.add(labelMesh);

      // Cap
      const capGeo = new THREE.CylinderGeometry(capRadius, capRadius, capHeight, 32);
      const capMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
      if (capColor) {
        try {
          capMat.color.setStyle(capColor);
        } catch {
          capMat.color.set(0xffd700); // fallback
        }
      }
      const capMesh = new THREE.Mesh(capGeo, capMat);
      capMesh.position.set(0, bottleHeight + capHeight/2, 0);

      bottleGroup.add(bottleMesh);
      bottleGroup.add(capMesh);

      // Position in final coords
      bottleGroup.position.set(slot.x, slot.y, slot.z);

      // userData for fly effect
      bottleGroup.userData.initialY = bottleGroup.position.y;
      bottleGroup.userData.flying   = false;
      bottleGroup.userData.notionData = bData;

      clickableBottles.push(bottleGroup);
      scene.add(bottleGroup);
    }

    // Utility: create label texture
    function createLabelTexture(text) {
      const canvas  = document.createElement('canvas');
      canvas.width  = 256;
      canvas.height = 819;
      const ctx     = canvas.getContext('2d');

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.font         = "60px Arial";
      ctx.fillStyle    = "#000000";
      ctx.textAlign    = "center";
      ctx.textBaseline = "middle";

      // rotate -90 degrees
      ctx.save();
      ctx.translate(0, canvas.height);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText(text, canvas.height / 2, canvas.width / 2);
      ctx.restore();

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      return texture;
    }

    // -------------------------------------------
    // 7) Interaction (fly up on click)
    // -------------------------------------------
    function onDocumentMouseDown(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(clickableBottles, true);

      if (intersects.length > 0) {
        let clickedGroup = intersects[0].object;
        while (clickedGroup.parent && !clickableBottles.includes(clickedGroup)) {
          clickedGroup = clickedGroup.parent;
        }
        if (activeBottle && activeBottle !== clickedGroup) {
          activeBottle.userData.flying = false;
        }
        activeBottle = clickedGroup;
        activeBottle.userData.flying = true;
      } else {
        if (activeBottle) {
          activeBottle.userData.flying = false;
        }
      }
    }

    // -------------------------------------------
    // 8) Main animation loop
    // -------------------------------------------
    function animate() {
      requestAnimationFrame(animate);

      if (activeBottle) {
        const initialY = activeBottle.userData.initialY;
        const targetY  = initialY + FLY_OFFSET;
        if (activeBottle.userData.flying) {
          // fly up
          if (activeBottle.position.y < targetY) {
            activeBottle.position.y += MOVE_SPEED;
            if (activeBottle.position.y > targetY) {
              activeBottle.position.y = targetY;
            }
          }
        } else {
          // drop down
          if (activeBottle.position.y > initialY) {
            activeBottle.position.y -= MOVE_SPEED;
            if (activeBottle.position.y < initialY) {
              activeBottle.position.y = initialY;
            }
          } else {
            activeBottle = null;
          }
        }
      }

      renderer.render(scene, camera);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>